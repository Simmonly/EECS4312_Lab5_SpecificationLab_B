## Student Name: Mohsen Maoodhah
## Student ID: 220153425

Prompt 1: I have a new lab that's is kind of an extension. This is the new requirement, and we must modify what we had based on this requirement. At least one resource must remain unallocated after assignment. This requirement applies in addition to all previously described behaviour. An allocation that satisfies all other conditions but consumes all available resources is no longer valid. Update your solution, tests, and documents to incorporate this requirement. Then it asks a few questions do you think your current solution satisfies the new requirement? which scenarios or cases do you expect to fail under the new requirement? What is the most likely cause of failure? which artificates do you expect to update (requirements/spec, code ,text, prompt strategy).

LLM Response 1: "Copy paste LLMs response"
No — your old is_allocation_feasible almost certainly does not satisfy the new requirement, because it probably only checks “requests ≤ resources” and returns True even when you use everything exactly.
What the new rule means (precisely)
After assigning all requests, there must be at least one leftover unit in at least one resource type.
So:
If resources are {'cpu': 4} and total requested cpu is 4 → NOW False
If resources are {'cpu': 4, 'gpu': 2} and totals are {'cpu': 4, 'gpu': 2} → NOW False
If totals fit and any one resource has leftover (resources[r] - total[r] >= 1) → OK True
Also, “unallocated” implies positive leftover, not just “resource exists but was never requested” unless it actually leaves capacity unused. (In practice, if a resource exists and no one requests it, that’s leftover and satisfies the new rule.)
Updated solution logic (what to change)
Keep all old checks, and add one more check at the end:
Validate inputs (same as before)
Compute totals requested per resource
If any request uses unknown resource → False
If any total exceeds available → False
New: Check that there exists at least one resource key r with
resources[r] - totals.get(r, 0) >= 1
If not, return False.
That means equality across all resources is now invalid.
Tests you should add / update
You’ll need to update tests that previously expected True when totals exactly match capacity.
New must-have tests
Exact consumption (single resource)
resources={'cpu':4}, requests=[{'cpu':2},{'cpu':2}] → False
Exact consumption (multi-resource)
resources={'cpu':4,'gpu':2}, requests=[{'cpu':4},{'gpu':2}] → False
Leaves 1 unit leftover somewhere
resources={'cpu':4,'gpu':2}, requests=[{'cpu':4}] → True (gpu untouched → leftover exists)
Leaves leftover by being under capacity
resources={'cpu':4}, requests=[{'cpu':3}] → True
Edge: zero leftover vs positive leftover
resources={'cpu':1}, requests=[{'cpu':1}] → False
resources={'cpu':1,'mem':0}, requests=[{'cpu':1}] → False (mem leftover is 0, cpu leftover 0)
The questions your lab asks (answers you can write)
1) Do you think your current solution satisfies the new requirement?
No. Because it likely returns True whenever totals are ≤ capacity, including the case when totals equal capacity (consumes everything), which is now invalid.
2) Which scenarios/cases do you expect to fail under the new requirement?
Any case where:
Every resource is either fully consumed or has 0 capacity leftover after assignment.
Typical failures:
Exact match between totals and resources for all resource types.
Single-resource cases where request sum equals capacity.
Multi-resource cases where each type is exactly used up.
3) What is the most likely cause of failure?
The code is missing a post-condition check for leftover resources — it only checks feasibility (<=) and doesn’t enforce “must leave slack”.
4) Which artifacts do you expect to update?
Definitely:
Requirements/spec: add the new rule + examples of invalid “exact consumption”.
Code (solution.py): implement the leftover check.
Tests (tests_solution.py): update expectations + add new cases.
Text/docs (write-up / rationale / answers): update explanation and test justification.
Prompt strategy (if you have one in the lab): update it to explicitly mention “must leave at least one unit unallocated” and include at least one example where equality should fail.
If you paste your current solution.py and tests_solution.py, I can rewrite them exactly with this rule (and point out which of your existing tests need to flip from True → False).
--------------------------------------------------
Prompt 2: 
## Student Name: Mohsen Maoodhah ## Student ID: 220153425 """ Stub file for the is allocation feasible exercise. Implement the function is_allocation_feasible to Determine whether a set of resource requests can be satisfied given limited capacities. Take int account any possible constraints. See the lab handout for full requirements. """ from typing import Dict, List, Union Number = Union[int, float] def is_allocation_feasible( resources: Dict[str, Number], requests: List[Dict[str, Number]] ) -> bool: # Checking if resources is a dictionary if not isinstance(resources, dict): raise ValueError("THe resources must be a dictionary") # Maps each resource to the total capacity. Initializes each resource in the resources to a value of 0 total_usage: Dict[str, Number] = {key: 0 for key in resources} # Going through the list of dictionaries to calculate the total sum for each resource for request in requests: # Making sure a request is a dictionary if not isinstance(request, dict): raise ValueError("each request must be a dict") for name, amount in request.items(): if name not in resources: return False if not isinstance(amount, (int, float)): raise ValueError("requested amount must be a number") total_usage[name] += amount for name, used in total_usage.items(): if used > resources[name]: return False return True
LLM Response 2: 
Updated solution.py
from typing import Dict, List, Union

Number = Union[int, float]


def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    # Checking if resources is a dictionary
    if not isinstance(resources, dict):
        raise ValueError("The resources must be a dictionary")

    # Maps each resource to the total usage. Initializes each resource in resources to 0.
    total_usage: Dict[str, Number] = {key: 0 for key in resources}

    # Going through the list of dictionaries to calculate the total sum for each resource
    for request in requests:
        # Making sure a request is a dictionary
        if not isinstance(request, dict):
            raise ValueError("Each request must be a dict")

        for name, amount in request.items():
            if name not in resources:
                return False
            if not isinstance(amount, (int, float)):
                raise ValueError("Requested amount must be a number")

            total_usage[name] += amount

    # Old rule: cannot exceed capacity
    for name, used in total_usage.items():
        if used > resources[name]:
            return False

    # New rule: at least one resource must remain unallocated (strictly positive leftover)
    # i.e., allocation is invalid if it consumes ALL available resources exactly.
    has_leftover = any((resources[name] - used) > 0 for name, used in total_usage.items())
    if not has_leftover:
        return False

    return True
Tests to add/update (tests_solution.py)
Here are the minimum new tests that directly cover the new rule:
import pytest
from solution import is_allocation_feasible

def test_exact_consumption_single_resource_now_invalid():
    resources = {"cpu": 4}
    requests = [{"cpu": 2}, {"cpu": 2}]
    assert is_allocation_feasible(resources, requests) is False

def test_exact_consumption_multi_resource_now_invalid():
    resources = {"cpu": 4, "gpu": 2}
    requests = [{"cpu": 4}, {"gpu": 2}]
    assert is_allocation_feasible(resources, requests) is False

def test_leaves_leftover_in_unused_resource_valid():
    resources = {"cpu": 4, "gpu": 2}
    requests = [{"cpu": 4}]
    # gpu remains completely unallocated -> valid under new rule
    assert is_allocation_feasible(resources, requests) is True

def test_leaves_leftover_by_underusing_capacity_valid():
    resources = {"cpu": 4}
    requests = [{"cpu": 3}]
    assert is_allocation_feasible(resources, requests) is True

--------------------------------------------------
prompt 3:
what's this now: rootdir: /Users/simmonly/Downloads/EECS4312_Lab5_SpecificationLab_B-main plugins: anyio-4.10.0 collected 13 items src/test_solution.py F............ [100%] ========================== FAILURES =========================== _____________ test_basic_feasible_single_resource _____________ def test_basic_feasible_single_resource(): # Basic Feasible Single-Resource # Constraint: total demand <= capacity # Reason: check basic functional requirement resources = {'cpu': 10} requests = [{'cpu': 3}, {'cpu': 4}, {'cpu': 3}] > assert is_allocation_feasible(resources, requests) is True E AssertionError: assert False is True E + where False = is_allocation_feasible({'cpu': 10}, [{'cpu': 3}, {'cpu': 4}, {'cpu': 3}]) src/test_solution.py:21: AssertionError =================== short test summary info =================== FAILED src/test_solution.py::test_basic_feasible_single_resource - AssertionError: assert False is True ================ 1 failed, 12 passed in 0.02s ================= (base) simmonly@Mohsens-MacBook-Pro EECS4312_Lab5_SpecificationLab_B-main %
LLM Response 3:
This failure is exactly because of the new rule you added.
Why that test fails now
Your test uses:
resources: cpu = 10
requests total: 3 + 4 + 3 = 10
So it consumes all available CPU → no leftover → under the new requirement this allocation is NOT valid, so your function correctly returns False.
But your test still expects True, which is now outdated.

✅ Fix: update that test’s expectation (and comment) to match the new requirement.

Updated version of that test (correct now)
def test_basic_feasible_single_resource():
    # Basic Single-Resource, but consumes ALL capacity
    # New requirement: at least one resource unit must remain unallocated
    resources = {'cpu': 10}
    requests = [{'cpu': 3}, {'cpu': 4}, {'cpu': 3}]
    assert is_allocation_feasible(resources, requests) is False
If you still want a “basic feasible single resource” test that returns True
Make it leave at least 1 unit unused:
def test_basic_feasible_single_resource_with_leftover():
    resources = {'cpu': 10}
    requests = [{'cpu': 3}, {'cpu': 4}, {'cpu': 2}]  # total = 9, leftover = 1
    assert is_allocation_feasible(resources, requests) is True
